<html>
  <head>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100dvh;
        width: 100dvh;
        overflow: hidden;
        background-color: red;
      }

      .content {
        inset: 0;
        position: absolute;
        overflow: hidden;
      }

      .content img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        object-position: center;
        position: absolute;
        inset: 0;
      }

      .crosshairs {
        background-color: gold;
        position: absolute;
        transition: transform linear;
        transition-duration: 1s;
      }

      .crosshairs.horizontal {
        width: 100dvw;
        height: 1px;
        top: -1px;
      }

      .crosshairs.vertical {
        width: 1px;
        height: 100dvh;
        left: -1px;
      }

      .marker {
        position: absolute;
        background-color: red;
      }

      .marker.x {
        width: 7px;
        height: 1px;
        margin-left: -3px;
      }

      .marker.y {
        width: 1px;
        height: 7px;
        margin-top: -3px;
      }

    </style>
    <script type="module">
      function getMapDimensions(imageWidth, imageHeight) {
        const containerWidth = window.innerWidth;
        const containerHeight = window.innerHeight;

        const containerAspectRatio = containerWidth / containerHeight;
        const imageAspectRatio = imageWidth / imageHeight;
        if (imageAspectRatio >= containerAspectRatio) {
          const mapHeight = containerHeight;
          const scale = mapHeight / imageHeight;
          const mapWidth = scale * imageWidth;
          const mapXOverflow = mapWidth - containerWidth;
          return { mapWidth, mapHeight, mapXOverflow, mapYOverflow: 0 };
        } else {
          const mapWidth = containerWidth;
          const scale = mapWidth / imageWidth;
          const mapHeight = scale * imageHeight;
          const mapYOverflow = mapHeight - containerHeight;
          return { mapWidth, mapHeight, mapXOverflow: 0, mapYOverflow };
        }
      }

      function latLngToPixel({
        mapWidth,
        mapHeight,
        lat,
        lng,
        mapXOverflow,
        mapYOverflow,
      }) {
        const x = (lng + 180) * (mapWidth / 360);
        const latRadians = (lat * Math.PI) / 180;
        const mercN = Math.log(Math.tan(Math.PI / 4 + latRadians / 2));
        const y = mapHeight / 2 - (mapWidth * mercN) / (2 * Math.PI);
        const RX = 1;
        const RY = 1;
        return {
          x: x * RX - mapXOverflow / 2,
          y: y * RY - mapYOverflow / 2,
        };
      }

      function promiseWithTimeout(timeout) {
        const { promise, resolve } = Promise.withResolvers();
        const timeoutPromise = new Promise(r => setTimeout(r, timeout));
        return {
          promise: Promise.race([promise, timeoutPromise]),
          resolve
        };
      }

      document.addEventListener("DOMContentLoaded", async () => {
        const response = await fetch('https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.geojson');
        const data = await response.json();

        const verticalLine = document.querySelector(".crosshairs.vertical");
        const horizontalLine = document.querySelector(".crosshairs.horizontal");
        const verticalStart = Math.random() * window.innerWidth
        const horizontalStart = Math.random() * window.innerWidth
        verticalLine.style.transform = `translate(${verticalStart}px, 0px)`;
        horizontalLine.style.transform = `translate(0px, ${horizontalStart}px)`;

        const mapImage = document.querySelector(".content img");
        const imageWidth = mapImage.naturalWidth;
        const imageHeight = mapImage.naturalHeight;

        const { mapWidth, mapHeight, mapXOverflow, mapYOverflow } =
          getMapDimensions(imageWidth, imageHeight);

        async function moveVerticalLine(x, currentX, totalDuration) {
          const viewportWidth = window.innerWidth;
          const directDistanceX = Math.abs(x - currentX);
          // How long the distance is if we go across date line (skipping from left edge
          // to right edge or right edge to left edge)
          const wrapDistanceX = viewportWidth - directDistanceX;
          const shouldWrapX = wrapDistanceX < directDistanceX;
          const effectiveDistanceX = shouldWrapX ? wrapDistanceX : directDistanceX;

          if (shouldWrapX) {
            let edgeX, oppositeEdgeX;
            if (x > currentX) {
              // We are jumping from left to right edge
              edgeX = 0;
              oppositeEdgeX = viewportWidth;
            } else {
              // We are jumping from right to left edge
              edgeX = viewportWidth;
              oppositeEdgeX = 0;
            }

            const distanceToEdge = Math.abs(edgeX - currentX);
            const distanceFromEdge = Math.abs(x - oppositeEdgeX);
            const durationToEdge = (distanceToEdge / effectiveDistanceX) * totalDuration;
            const durationFromEdge = (distanceFromEdge / effectiveDistanceX) * totalDuration;

            // Transition the crosshair line to the edge from where we jump
            const { promise: toEdge, resolve: resolveToEdge } = promiseWithTimeout(durationToEdge + 30);
            const handlerToEdge = () => {
              verticalLine.removeEventListener('transitionend', handlerToEdge);
              resolveToEdge();
            };
            verticalLine.addEventListener('transitionend', handlerToEdge);
            verticalLine.style.transitionDuration = `${durationToEdge}ms`;
            verticalLine.style.transform = `translate(${edgeX}px, 0px)`;

            // Wait for the transition to end
            await toEdge;

            // Teleport the crosshair line to the other edge
            verticalLine.style.transitionDuration = '0ms';
            verticalLine.style.transform = `translate(${oppositeEdgeX}px, 0px)`;

            // Wait for one frame to make sure the teleport took effect
            await new Promise(resolve => requestAnimationFrame(resolve));

            // Transition from the other edge to the final location
            const { promise: fromEdge, resolve: resolveFromEdge } = promiseWithTimeout(durationFromEdge + 30);
            const handlerFromEdge = () => {
              verticalLine.removeEventListener('transitionend', handlerFromEdge);
              resolveFromEdge();
            };
            verticalLine.addEventListener('transitionend', handlerFromEdge);
            verticalLine.style.transitionDuration = `${durationFromEdge}ms`;
            verticalLine.style.transform = `translate(${x}px, 0px)`;

            await fromEdge;
          } else {
            // Base case, transition directly to the final location
            const { promise, resolve } = promiseWithTimeout(totalDuration + 30);
            const handler = () => {
              verticalLine.removeEventListener('transitionend', handler);
              resolve();
            };
            verticalLine.addEventListener('transitionend', handler);
            verticalLine.style.transitionDuration = `${totalDuration}ms`;
            verticalLine.style.transform = `translate(${x}px, 0px)`;

            await promise;
          }
        }

        async function moveHorizontalLine(y, currentY, totalDuration) {
          const viewportHeight = window.innerHeight;
          const directDistanceY = Math.abs(y - currentY);
          // How long the distance is if we go across north / south pole (skipping from
          // top to bottom or bottom to top)
          const wrapDistanceY = viewportHeight - directDistanceY;
          const shouldWrapY = wrapDistanceY < directDistanceY;
          const effectiveDistanceY = shouldWrapY ? wrapDistanceY : directDistanceY;

          if (shouldWrapY) {
            let edgeY, oppositeEdgeY;
            if (y > currentY) {
              // We are jumping from top edge to bottom edge
              edgeY = 0;
              oppositeEdgeY = viewportHeight;
            } else {
              // We are jumping from bottom edge to top edge
              edgeY = viewportHeight;
              oppositeEdgeY = 0;
            }

            const distanceToEdge = Math.abs(edgeY - currentY);
            const distanceFromEdge = Math.abs(y - oppositeEdgeY);
            const durationToEdge = (distanceToEdge / effectiveDistanceY) * totalDuration;
            const durationFromEdge = (distanceFromEdge / effectiveDistanceY) * totalDuration;

            // Transition the crosshair line to the edge from where we jump
            const { promise: toEdge, resolve: resolveToEdge } = promiseWithTimeout(durationToEdge + 30);
            const handlerToEdge = () => {
              horizontalLine.removeEventListener('transitionend', handlerToEdge);
              resolveToEdge();
            };
            horizontalLine.addEventListener('transitionend', handlerToEdge);
            horizontalLine.style.transitionDuration = `${durationToEdge}ms`;
            horizontalLine.style.transform = `translate(0px, ${edgeY}px)`;

            // Wait for the transition to finish
            await toEdge;

            // Teleport the line to the opposite edge
            horizontalLine.style.transitionDuration = '0ms';
            horizontalLine.style.transform = `translate(0px, ${oppositeEdgeY}px)`;

            // Wait for one frame to make sure the teleport took effect
            await new Promise(resolve => requestAnimationFrame(resolve));

            // Transition to the final location
            const { promise: fromEdge, resolve: resolveFromEdge } = promiseWithTimeout(durationFromEdge + 30);
            const handlerFromEdge = () => {
              horizontalLine.removeEventListener('transitionend', handlerFromEdge);
              resolveFromEdge();
            };
            horizontalLine.addEventListener('transitionend', handlerFromEdge);
            horizontalLine.style.transitionDuration = `${durationFromEdge}ms`;
            horizontalLine.style.transform = `translate(0px, ${y}px)`;

            await fromEdge;
          } else {
            // Base case, transition directly to the final location
            const { promise, resolve } = promiseWithTimeout(totalDuration + 30);
            const handler = () => {
              horizontalLine.removeEventListener('transitionend', handler);
              resolve();
            };
            horizontalLine.addEventListener('transitionend', handler);
            horizontalLine.style.transitionDuration = `${totalDuration}ms`;
            horizontalLine.style.transform = `translate(0px, ${y}px)`;

            await promise;
          }
        }

        async function moveToCoordinates(x, y) {
          const currentX =
            parseFloat(
              verticalLine.style.transform.match(
                /translate.([0-9]*\.[0-9]*)px/
              )?.[1]
            ) || 0;
          const currentY =
            parseFloat(
              horizontalLine.style.transform.match(
                /translate\(0px, ([0-9]*\.[0-9]*)/
              )?.[1]
            ) || 0;

          const viewportWidth = window.innerWidth;
          const directDistanceX = Math.abs(x - currentX);
          // How long the distance is if we go across date line (skipping from left edge
          // to right edge or right edge to left edge)
          const wrapDistanceX = viewportWidth - directDistanceX;
          const shouldWrapX = wrapDistanceX < directDistanceX;
          const effectiveDistanceX = shouldWrapX ? wrapDistanceX : directDistanceX;

          const viewportHeight = window.innerHeight;
          const directDistanceY = Math.abs(y - currentY);
          // How long the distance is if we go across north / south pole (skipping from
          // top to bottom or bottom to top)
          const wrapDistanceY = viewportHeight - directDistanceY;
          const shouldWrapY = wrapDistanceY < directDistanceY;
          const effectiveDistanceY = shouldWrapY ? wrapDistanceY : directDistanceY;

          // The distance when traveling the shortest path
          const totalDistance = Math.sqrt(effectiveDistanceX ** 2 + effectiveDistanceY ** 2);
          const totalDuration = totalDistance / 0.5;

          await Promise.all([
            moveVerticalLine(x, currentX, totalDuration),
            moveHorizontalLine(y, currentY, totalDuration)
          ]);
        }

        function markCoordinate(x, y) {
          const markerX = document.createElement("div");
          markerX.classList.add("marker", "x");
          markerX.style.left = `${x}px`;
          markerX.style.top = `${y}px`;
          document.querySelector(".content").append(markerX);
          const markerY = document.createElement("div");
          markerY.classList.add("marker", "y");
          markerY.style.left = `${x}px`;
          markerY.style.top = `${y}px`;
          document.querySelector(".content").append(markerY);
        }

        let i = 0;
        while (true) {
          const earthquake = data.features[i % data.features.length];
          const { x, y } = latLngToPixel({
            mapWidth,
            mapHeight,
            mapXOverflow,
            mapYOverflow,
            lat: earthquake.geometry.coordinates[1],
            lng: earthquake.geometry.coordinates[0],
          });
          await moveToCoordinates(x, y);
          markCoordinate(x, y);
          i++;
        }
      });
    </script>
  </head>

  <body>
    <div class="content">
      <img src="./map_bw.jpg" alt="World map" width="2058" height="2058">
      <div class="crosshairs horizontal"></div>
      <div class="crosshairs vertical"></div>
    </div>
  </body>
</html>
